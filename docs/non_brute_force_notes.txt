P = Player marble
E = Enemy marble
A = Available
O = Out of bounds

P, E - terminate
P, A - terminate, add
P, O - terminate

P, P, E
P, P, E, E - terminate
P, P, E, A - terminate, add (sumito)
P, P, E, O - terminate, add (sumito, u-u-u-u-ultra kill)
P, P, A - terminate, add
P, P, O - terminate

P, P, P, E
P, P, P, E, E
P, P, P, E, E, E - terminate
P, P, P, E, E, A - terminate, add (sumito)
P, P, P, E, E, O - terminate, add (sumito, mega kill)
P, P, P, E, A - terminate, add (sumito)
P, P, P, E, O - terminate, add (sumito, micro kill)
P, P, P, A - terminate, add
P, P, P, O - terminate

P, P, P, P - terminate

terminate:
    next = A
    next = O
    num_players = num_enemies

    num_players > 3

when add:
    terminate && (num_players > num_enemies)

when sumito:
    enemies > 1

when kill:
    next = O


   NW       NE
    \      /
      ⟋  ⟍
W --  ⎸  ⎹  -- E
      ⟍  ⟋
     /     \
   SW       SE

absolute_directions = [10, 11, 1]
valid_inline_patterns = [
                            ...
                            lisa patterns
                        ]
bounds = {
    1: (1, 5)
    2: (1, 6)
    3: (1, 7)
    4: (1, 8)
    5: (1, 9)
    6: (2, 9)
    7: (3, 9)
    8: (4, 9)
    9: (5, 9)
}

# to figure out the bounds of a coordinate, div for row, check map, get min/max
# e.g.
#   coord = 82
#   row = coord // 10 = 8
#   col = coord % 10 = 2
#   out_of_bounds = col < bounds[row][0] or col > bounds[row][1]

def gen_all_moves():
    inline_moves, sidestep_groupdirs = gen_all_sidegroupdirs_inmoves()
    sidestep_moves = gen_sidemoves(sidestep_groupdirs)
    return inline_moves + sidestep_moves

def gen_sidemoves(groupdirs):
    sidemoves = []

    for groupdir in groupdirs:
        # example groupdir: ((34, 35, 36), 11)
        for direction in absolute_directions:
            if direction == groupdir[1]:
                continue

            if is_valid_sidemove(group_dir[0], direction):
                sidemoves.append((group_dir[0], direction))

            if is_valid_sidemove(group_dir[0], -direction):
                sidemoves.append((group_dir[0], -direction))

def is_valid_sidemove(group, direction):
    for marble in group:
        if marble + direction != AVAILABLE:
            return False
    return True

def gen_all_sidegroupdirs_inmoves():
    sidestep_groupdirs = []
    inline_moves = []

    for marble in player_turn's color:
        for direction in absolute_directions:
            inline_move_to_add, sidestep_groupdirs_to_add = gen_sidesteps_and_inlines(marble, direction)

            inline_moves.append(inline_move_to_add)
            sidestep_groupdirs.append(sidestep_groupdirs_to_add)

            inline_move_to_add = gen_inlines(marble, -direction)
            inline_moves.append(inline_move_to_add)

    return inline_moves, sidestep_groupdirs

def gen_single_sidegroupdirs_and_inmove(marble, direction):
    sidestep_groupdirs = []
    cur_grouping = [marble]
    next = marble + direction

    num_players = 1
    num_enemies = 0

    while True:
        # add sidestep logic later
        if next == AVAILABLE:
           or next == OUT_OF_BOUNDS
           or num_players == num_enemies
           or num_players > 3
           break # terminate

        cur_grouping.append(next)

        if next == PLAYER:
            sidestep_groupdirs.append((cur_grouping, direction))
            num_players += 1
        elif next == ENEMY:
            num_enemies += 1

        next += direction

    if next == OUT_OF_BOUNDS and cur_grouping[-1] == PLAYER:
        return (None, sidestep_groupdirs)
    elif num_players == 4:
        return (None, sidestep_groupdirs)
    elif num_players > num_enemies:
        return ((cur_grouping, direction), sidestep_groupdirs)
    else:
        return (None, sidestep_groupdirs)


def gen_single_inmove(marble, direction):
    cur_grouping = [marble]
    next = marble + direction

    num_players = 1
    num_enemies = 0

    while True:
        # add sidestep logic later
        if next == AVAILABLE
           or next == OUT_OF_BOUNDS
           or num_players == num_enemies
           or num_players > 3
           break # terminate

        cur_grouping.append(next)

        if next == PLAYER:
            num_players += 1
        elif next == ENEMY:
            num_enemies += 1

        next += direction

    if next == OUT_OF_BOUNDS and cur_grouping[-1] == PLAYER:
        return None
    elif num_players == 4:
        return None
    elif num_players > num_enemies:
        return (cur_grouping, direction)
    else:
        return None
